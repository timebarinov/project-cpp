# Транспортный справочник, часть E

В этой задаче вам необходимо написать простую библиотеку для вывода векторных изображений в формате SVG. Поскольку основное применение этой библиотеки в рамках курса — визуализация «Транспортного справочника», достаточно реализовать три типа объектов:

* Круг (Circle). Описывается координатами центра и радиусом.

* Ломаная (Polyline). Описывается координатами вершин.

* Надпись (Text). Описывается текстовым содержимым, координатами опорной точки, смещением относительно опорной точки, размером и названием шрифта.

Кроме того, все типы объектов имеют следующие свойства:

* цвет линии и цвет заливки;

* толщина линии;

* тип формы конца линии и соединения линий.

Весь код библиотеки должен находиться в пространстве имён Svg.

**Пример**

#### Ввод

    Svg::Document svg;

    svg.Add(
        Svg::Polyline{}
        .SetStrokeColor(Svg::Rgb{140, 198, 63})  // soft green
        .SetStrokeWidth(16)
        .SetStrokeLineCap("round")
        .AddPoint({50, 50})
        .AddPoint({250, 250})
    );

    for (const auto point : {Svg::Point{50, 50}, Svg::Point{250, 250}}) {
    svg.Add(
        Svg::Circle{}
        .SetFillColor("white")
        .SetRadius(6)
        .SetCenter(point)
    );
    }

    svg.Add(
        Svg::Text{}
        .SetPoint({50, 50})
        .SetOffset({10, -10})
        .SetFontSize(20)
        .SetFontFamily("Verdana")
        .SetFillColor("black")
        .SetData("C")
    );
    svg.Add(
        Svg::Text{}
        .SetPoint({250, 250})
        .SetOffset({10, -10})
        .SetFontSize(20)
        .SetFontFamily("Verdana")
        .SetFillColor("black")
        .SetData("C++")
    );

    svg.Render(std::cout);

#### Вывод

    <?xml version="1.0" encoding="UTF-8" ?><svg xmlns="http://www.w3.org/2000/svg" version="1.1"><polyline points="50,50 250,250 " fill="none" stroke="rgb(140,198,63)" stroke-width="16" stroke-linecap="round" /><circle cx="50" cy="50" r="6" fill="white" stroke="none" stroke-width="1" /><circle cx="250" cy="250" r="6" fill="white" stroke="none" stroke-width="1" /><text x="50" y="50" dx="10" dy="-10" font-size="20" font-family="Verdana" fill="black" stroke="none" stroke-width="1" >C</text><text x="250" y="250" dx="10" dy="-10" font-size="20" font-family="Verdana" fill="black" stroke="none" stroke-width="1" >C++</text></svg>

## Требования к вспомогательным классам

**Point**

Point — структура из двух полей x и y типа double. Необходимо иметь возможность создать точку с помощью выражения Point{x, y}, а также создать с помощью конструктора по умолчанию и затем заполнить поля x и y прямым обращением к ним.

**Rgb**

Rgb — структура из целочисленных полей red, green, blue. Необходимо иметь возможность создать объект с помощью выражения Rgb{red, green, blue}, а также создать с помощью конструктора по умолчанию и затем заполнить поля red, green и blue прямым обращением к ним. Поля будут заполняться значениями от 0 до 255. Валидация их инициализированности и попадания значений в диапазон [0, 255] не требуется: в случае нарушения этих требований допускается undefined behaviour.

**Color**

Color — тип, который можно проинициализировать одним из трёх способов:

* Конструктором по умолчанию. Такой цвет выводится как none.

* Строкой (std::string). Такой цвет выводится непосредственно как содержимое строки.

* Структурой Rgb. Такой цвет выводится в виде rgb(red,green,blue) (см. примеры).

Тип должен допускать неявную инициализацию строкой или Rgb.

Кроме того, для удобства и улучшения читаемости должна существовать глобальная константа Svg::NoneColor, представляющая собой объект класса Color, созданный с помощью конструктора по умолчанию. (По аналогии, например, с std::nullopt.)

**Document**

Document — класс, с помощью которого производится компоновка и отрисовка SVG-документа. Класс должен поддерживать следующие операции:

1. Создание с помощью конструктора по умолчанию: Svg::Document svg;

2. Добавление объекта: svg.Add(object), где object имеет тип Circle, Polyline или Text. Обратите внимание, что таким образом поддерживается лишь линейная структура документа: составляющие его объекты по сути образуют массив.

3. Отрисовка (формирование результирующей строки): svg.Render(out), где out — наследник std::ostream.

### Отрисовка

Строка, собираемая в методе Svg::Document::Render, должна быть устроена следующим образом:

1. <?xml version="1.0" encoding="UTF-8" ?>

2. <svg xmlns="http://www.w3.org/2000/svg" version="1.1">

3. Объекты, добавленные с помощью Svg::Document::Add, в порядке их добавления.

4. </svg>

Все свойства объектов выводятся в следующем формате: название свойства, символ = и затем значение в кавычках.

Лишние пробельные символы допускаются:

1. Между тегами. (За исключением текста между открывающим и закрывающим тегами <text>.)

2. Между свойствами, перед и после списка свойств, вокруг символа =, разделяющего название свойства и значение.

3. Между координатами, перед и после списка координат в значении свойства points.

**Circle**

Круг отображается следующим образом: строка "<circle ", затем через пробел свойства в произвольном порядке, затем строка "/>"

**Polyline**

Ломаная отображается следующим образом: строка "<polyline ", затем через пробел свойства в произвольном порядке, затем строка "/>"

**Text**

Текст отображается следующим образом: строка "<text ", затем через пробел свойства в произвольном порядке, затем символ ">", содержимое надписи и, наконец, закрывающий тег "</text>"
Прочие требования

1. Библиотека может содержать и другие вспомогательные классы, необходимые для реализации упомянутых требований. Более того, без этого не удастся получить достаточно поддерживаемый код.

2. Упомянутые классы могут содержать и другие методы, кроме ситуаций, когда это противоречит требованию п. 4.

3. Вызовы методов при создании объектов Circle, Polyline или Text могут объединяться в цепочки в произвольном порядке.

4. Классы объектов Circle, Polyline или Text должны поддерживать свои и только свои методы выставления свойств. Например, не должны компилироваться выражения Svg::Text{}.SetRadius(0) или Svg::Circle{}.SetData("").

5. Широкая поддержка rvalue-семантики не требуется. В частности, в выражении svg.Add(Svg::Polyline{}.AddPoint({0, 0}).AddPoint({1, 2})) не обязан вызываться move-конструктор ломаной. Тем не менее, реализация этого — довольно интересное упражнение. Помимо этого, мы настоятельно рекомендуем поддержать форсирование перемещения при добавлении объекта с помощью следующего выражения: svg.Add(move(polyline)).

6. Экранирование при выводе строк поддерживать не требуется: достаточно выводить их как есть.

7. Вывод вещественных чисел должен осуществляться стандартным механизмом, без модификаторов вывода. При тестировании вещественные числа будут сравниваться с относительной точностью 1e-6.

8. Ограничения допускают любое адекватное линейное решение: за 1 секунду нужно успевать обрабатывать 100000 вызовов конструкторов объектов и методов выставления свойств, а также один вызов Svg::Document::Render.
